# coding=utf-8
#
# This file is part of Hypothesis, which may be found at
# https://github.com/HypothesisWorks/hypothesis-python
#
# Most of this work is copyright (C) 2013-2018 David R. MacIver
# (david@drmaciver.com), but it contains contributions by others. See
# CONTRIBUTING.rst for a full list of people who may hold copyright, and
# consult the git log if you need to determine who owns an individual
# contribution.
#
# This Source Code Form is subject to the terms of the Mozilla Public License,
# v. 2.0. If a copy of the MPL was not distributed with this file, You can
# obtain one at http://mozilla.org/MPL/2.0/.
#
# END HEADER

from __future__ import division, print_function, absolute_import

from hypothesis.errors import InvalidArgument
from hypothesis.internal import charmap
from hypothesis.internal.compat import hunichr, binary_type, int_to_bytes
from hypothesis.internal.intervalsets import IntervalSet
from hypothesis.internal.conjecture.utils import choice, integer_range, \
    calc_label_from_name
from hypothesis.searchstrategy.strategies import SearchStrategy, \
    MappedSearchStrategy

ONE_UNICODE_CHAR_LABEL = calc_label_from_name('one unicode character')


class OneCharStringStrategy(SearchStrategy):
    """A strategy which generates single character strings of text type."""

    def __init__(self,
                 whitelist_categories=None,
                 blacklist_categories=None,
                 blacklist_characters=None,
                 min_codepoint=None,
                 max_codepoint=None,
                 whitelist_characters=None):
        assert set(whitelist_categories or ()).issubset(charmap.categories())
        assert set(blacklist_categories or ()).issubset(charmap.categories())
        intervals = charmap.query(
            include_categories=whitelist_categories,
            exclude_categories=blacklist_categories,
            min_codepoint=min_codepoint,
            max_codepoint=max_codepoint,
            include_characters=whitelist_characters,
            exclude_characters=blacklist_characters,
        )
        if not intervals:
            arguments = [
                ('whitelist_categories', whitelist_categories),
                ('blacklist_categories', blacklist_categories),
                ('whitelist_characters', whitelist_characters),
                ('blacklist_characters', blacklist_characters),
                ('min_codepoint', min_codepoint),
                ('max_codepoint', max_codepoint),
            ]
            raise InvalidArgument(
                'No characters are allowed to be generated by this '
                'combination of arguments: ' + ', '.join(
                    '%s=%r' % arg for arg in arguments if arg[1] is not None)
            )
        self.category_intervals = [IntervalSet(i) for i in intervals]
        all_intervals = sorted(sum(intervals, ()), reverse=True)
        self.all_intervals = IntervalSet(
            charmap._union_intervals(all_intervals[:1], all_intervals[1:])
        )

    def get_char_idx(self, data, category):
        return category[integer_range(
            data, 0, len(category) - 1,
            center=category.index_above(ord('0'))
        )]

    def do_draw(self, data):
        # Drawing a unicode character uses the "shrink open" trick - we start
        # by drawing a boolean (from eight bits), a category, and a character
        # within that category.  Note that this is grouped in an example, so
        # that it can be easily zeroed by the shrinker later.
        data.start_example(ONE_UNICODE_CHAR_LABEL)
        use_category = data.draw_bits(8) != 0
        category = choice(data, self.category_intervals)
        char_idx = self.get_char_idx(data, category)
        data.stop_example()
        # After generating by index-within-category, we want to shrink by
        # codepoint instead.  We therefore write the bytes that would generate
        # this char_idx by codepoint.  When the shrinker zeros out the first
        # example the value of char_idx will be determined by the written
        # bytes, and after that shrinking depends only on the codepoint.
        if use_category:
            data.write(int_to_bytes(self.all_intervals.index(char_idx), 4))
        else:
            char_idx = self.get_char_idx(data, self.all_intervals)
        return hunichr(char_idx)


class StringStrategy(MappedSearchStrategy):
    """A strategy for text strings, defined in terms of a strategy for lists of
    single character text strings."""

    def __init__(self, list_of_one_char_strings_strategy):
        super(StringStrategy, self).__init__(
            strategy=list_of_one_char_strings_strategy
        )

    def __repr__(self):
        return "%r.map(u''.join)" % self.mapped_strategy

    def pack(self, ls):
        return u''.join(ls)


class BinaryStringStrategy(MappedSearchStrategy):
    """A strategy for strings of bytes, defined in terms of a strategy for
    lists of bytes."""

    def __repr__(self):
        return '%r.map(bytearray).map(%s)' % (
            self.mapped_strategy, binary_type.__name__)

    def pack(self, x):
        assert isinstance(x, list), repr(x)
        ba = bytearray(x)
        return binary_type(ba)


class FixedSizeBytes(SearchStrategy):

    def __init__(self, size):
        self.size = size

    def do_draw(self, data):
        return binary_type(data.draw_bytes(self.size))
