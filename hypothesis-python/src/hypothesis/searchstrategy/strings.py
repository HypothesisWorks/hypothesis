# coding=utf-8
#
# This file is part of Hypothesis, which may be found at
# https://github.com/HypothesisWorks/hypothesis/
#
# Most of this work is copyright (C) 2013-2019 David R. MacIver
# (david@drmaciver.com), but it contains contributions by others. See
# CONTRIBUTING.rst for a full list of people who may hold copyright, and
# consult the git log if you need to determine who owns an individual
# contribution.
#
# This Source Code Form is subject to the terms of the Mozilla Public License,
# v. 2.0. If a copy of the MPL was not distributed with this file, You can
# obtain one at https://mozilla.org/MPL/2.0/.
#
# END HEADER

from __future__ import absolute_import, division, print_function

from hypothesis.errors import InvalidArgument
from hypothesis.internal import charmap
from hypothesis.internal.compat import binary_type, hunichr
from hypothesis.internal.conjecture.utils import calc_label_from_name, choice
from hypothesis.internal.intervalsets import IntervalSet
from hypothesis.searchstrategy.strategies import MappedSearchStrategy, SearchStrategy

ONE_UNICODE_CHAR_LABEL = calc_label_from_name("one unicode character")


class OneCharStringStrategy(SearchStrategy):
    """A strategy which generates single character strings of text type."""

    def __init__(
        self,
        whitelist_categories=None,
        blacklist_categories=None,
        blacklist_characters=None,
        min_codepoint=None,
        max_codepoint=None,
        whitelist_characters=None,
    ):
        assert set(whitelist_categories or ()).issubset(charmap.categories())
        assert set(blacklist_categories or ()).issubset(charmap.categories())
        intervals = charmap.query(
            include_categories=whitelist_categories,
            exclude_categories=blacklist_categories,
            min_codepoint=min_codepoint,
            max_codepoint=max_codepoint,
            include_characters=whitelist_characters,
            exclude_characters=blacklist_characters,
        )
        if not intervals:
            arguments = [
                ("whitelist_categories", whitelist_categories),
                ("blacklist_categories", blacklist_categories),
                ("whitelist_characters", whitelist_characters),
                ("blacklist_characters", blacklist_characters),
                ("min_codepoint", min_codepoint),
                ("max_codepoint", max_codepoint),
            ]
            raise InvalidArgument(
                "No characters are allowed to be generated by this "
                "combination of arguments: "
                + ", ".join("%s=%r" % arg for arg in arguments if arg[1] is not None)
            )
        self.category_intervals = [IntervalSet(i) for i in intervals]
        self.all_intervals = IntervalSet(
            charmap._union_intervals(intervals[0][:1], sum(intervals, ()))
        )
        self.zero_point = self.all_intervals.index_above(ord("0"))

    def do_draw(self, data):
        # If there's only one category, we don't need to do anything complicated.
        if len(self.category_intervals) == 1:
            return hunichr(choice(data, self.all_intervals, self.zero_point))
        # Drawing a unicode character uses the "shrink open" trick - we start
        # by drawing a boolean (from eight bits), a category, and a character
        # within that category.  Note that this is grouped in an example, so
        # that it can be easily zeroed by the shrinker later.
        data.start_example(ONE_UNICODE_CHAR_LABEL)
        use_category = data.draw_bits(8) != 0
        category = choice(data, self.category_intervals)
        char_idx = choice(data, category, category.index_above(ord("0")))
        data.stop_example()
        # After generating by index-within-category, we want to shrink by
        # codepoint instead.  We therefore write the bytes that would generate
        # this char_idx by codepoint.  When the shrinker zeros out the first
        # example the value of char_idx will be determined by the written
        # bytes, and after that shrinking depends only on the codepoint.
        forced = None if use_category else self.all_intervals.index_above(char_idx)
        char_idx = choice(data, self.all_intervals, self.zero_point, forced)
        return hunichr(char_idx)


class StringStrategy(MappedSearchStrategy):
    """A strategy for text strings, defined in terms of a strategy for lists of
    single character text strings."""

    def __init__(self, list_of_one_char_strings_strategy):
        super(StringStrategy, self).__init__(strategy=list_of_one_char_strings_strategy)

    def __repr__(self):
        return "%r.map(u''.join)" % self.mapped_strategy

    def pack(self, ls):
        return u"".join(ls)


class BinaryStringStrategy(MappedSearchStrategy):
    """A strategy for strings of bytes, defined in terms of a strategy for
    lists of bytes."""

    def __repr__(self):
        return "%r.map(bytearray).map(%s)" % (
            self.mapped_strategy,
            binary_type.__name__,
        )

    def pack(self, x):
        assert isinstance(x, list), repr(x)
        ba = bytearray(x)
        return binary_type(ba)


class FixedSizeBytes(SearchStrategy):
    def __init__(self, size):
        self.size = size

    def do_draw(self, data):
        return binary_type(data.draw_bytes(self.size))
