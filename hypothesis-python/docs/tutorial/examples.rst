Explicit examples
=================

If you want Hypothesis to always run a specific input, you can use the |@example| decorator. |@example| adds an explicit input which Hypothesis will run every time, in addition to the randomly generated examples. You can think of explicit examples as combining unit-testing with property-based testing.

For instance, suppose we are testing something using integers, but want to make sure we try a few large prime numbers on every test run. We can add these primes with an explicit |@example|:

.. code-block:: python

    # mersenne primes
    @example(2**17 - 1)
    @example(2**19 - 1)
    @given(st.integers())
    def test_something_with_integers(n):
        pass

Hypothesis runs all explicit examples first, in the |Phase.explicit| phase, before generating additional random examples in the |Phase.generate| phase.

Explicit examples do not shrink
-------------------------------

Unlike examples generated by Hypothesis, examples provided using |@example| do not shrink. Let's see this by adding an assertion to the example above:

.. code-block:: python

    @example(2**17 - 1)
    @given(st.integers())
    def test_something_with_integers(n):
        assert n < 100

Hypothesis will give output ``Falsifying explicit example: test_something_with_integers(n=131071)``, instead of shrinking to ``n=100``.
