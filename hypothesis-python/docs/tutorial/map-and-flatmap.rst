``.map()`` and ``.flatmap()``
=============================

The two functions are available on all strategies, and are useful for transforming examples from a strategy into a related value.

.. _mapping:

``.map()``
----------

``strategy.map(f)`` transforms all examples generated by ``strategy`` by calling ``f`` on them. For instance:

.. code-block:: pycon

    >>> lists(integers()).map(sorted).example()
    [-25527, -24245, -93, -70, -7, 0, 39, 65, 112, 6189, 19469, 32526, 1566924430]

.. _flatmap:

``.flatmap()``
--------------

``strategy.flatmap()`` transforms all examples generated into a strategy, then draws an example from that strategy.

It may not be obvious why this is useful at first. It turns out to let you generate different types of data with relationships to each other.

For example, suppose we wanted to generate a list of lists of the same length:

.. code-block:: pycon

    >>> rectangle_lists = integers(min_value=0, max_value=10).flatmap(
    ...     lambda n: lists(lists(integers(), min_size=n, max_size=n))
    ... )
    >>> rectangle_lists.example()
    []
    >>> rectangle_lists.filter(lambda x: len(x) >= 10).example()
    [[], [], [], [], [], [], [], [], [], []]
    >>> rectangle_lists.filter(lambda t: len(t) >= 3 and len(t[0]) >= 3).example()
    [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
    >>> rectangle_lists.filter(lambda t: sum(len(s) for s in t) >= 10).example()
    [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0]]

In this example we first choose a length for our lists, then we build a strategy which generates lists containing lists precisely of that length.

While we could also have expressed this using |st.data| or |st.composite|, ``.flatmap()`` is a more concise and inline alternative.
